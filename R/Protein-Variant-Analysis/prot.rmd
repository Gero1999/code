---
title: "proteins"
author: "Gerardo José Rodríguez"
date: "2022-10-26"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(Biostrings)
library(dplyr)
library(ggplot2)
library(tidyverse)
```

## R Markdown
Lets consider a native sequence and make a mutagenesis library. For that we will need a random-substitution function.

```{r}
# Define the initial sequence
nat =  DNAString("ATGGGTAACATCTAA")

# Alternatively read it from a FASTA file
nat = readDNAStringSet('native_DNA.fa')[[1]]

# Define a substitution function
make_substitution = function(seq, site=FALSE, nucl=FALSE){
  if (site==FALSE){site=sample(c(1:nchar(seq)),1)}
  if (nucl==FALSE){nucl=sample(c('A','C','G','T'),1)}
  c(seq=replaceLetterAt(seq, at=site, nucl),
    mut=c(paste0(site, nat[site],'>',nucl)))}

# Perform the function over a set of your original sequence
set = rep(DNAStringSet(nat),1000)
set = lapply(set, \(dna) make_substitution(dna)$seq)
```

### Determine frequency at each position of each nucleotide

```{r}
cm_dna = consensusMatrix(DNAStringSet(set))[DNA_BASES,]
cm_dna
```


### Determine frequency at each position of each residue
```{r}
# Translate your DNA set to a protein set
prot_set = AAStringSet(lapply(DNAStringSet(set), \(x) translate(x)))

resFreqPerPos = function(prot_set){
  # Build a count matrix
  cm_res = consensusMatrix(AAStringSet(prot_set))
  # Determine which AA are not represented to complete the table content with 0s
  AAtoAdd = setdiff(AA_ALPHABET, rownames(cm_res))
  rbind(cm_res, matrix(0, nrow=length(AAtoAdd), ncol=ncol(cm_res),
                       dimnames=list(AAtoAdd, 1:ncol(cm_res))))
}
resFreqPerPos(prot_set)
```

# Determine each residue-pair substitution frequence
```{r}
# I CREATED TWO POTENTIAL FUNCTIONS. THE SECOND ONE IS ALMOST 5x FASTER, BUT DO NOT CREATE STANDARD TABLES (ONLY NECESSARY AMINOACIDS WITH AT LEAST ONE COUNT)
nat_prot = translate(nat)

subMtx = function(prot_set, nat_prot){
  # Create a count pair-matrix
  sub_mtx = matrix(0, nrow=length(AA_ALPHABET), ncol=length(AA_ALPHABET),
                   dimnames=list(AA_ALPHABET, AA_ALPHABET))
  # Find the residue-pairs in the substitutions and summarize them in a table
  pairs = table(unlist(sapply(prot_set, function(prot){
    pos = which(as.integer(nat_prot)!=as.integer(prot), useNames = T)
    paste0(as.vector(nat_prot[pos]), as.vector(prot[pos]))
  })))
  # Fill the matrix values with the correspondant counts for each pair
  for (p in 1:length(pairs)){
    sub_mtx[substr(names(pairs)[p],1,1), substr(names(pairs)[p],2,2)] = pairs[p]
  }
  sub_mtx
}

subMtx2 = function(prot_set, nat_prot=NULL){
  
  # Create a consensus protein (in case is not given)
  if (is.null(nat_prot)){nat_prot=consensusString(prot_set)}
  
  # Align sequences and find all mismatches. Reshape the object in a mtx
  prot_set_aligned = pairwiseAlignment(prot_set, nat_prot) 
  sub_mtx = mismatchSummary(prot_set_aligned)$subject %>%
    group_by(Subject, Pattern) %>%
    summarize(Count=sum(Count)) %>%
    xtabs(data=., formula=Count~Subject+Pattern)
    AAtoAdd_row = setdiff(AA_ALPHABET, rownames(sub_mtx))
    AAtoAdd_col = setdiff(AA_ALPHABET, colnames(sub_mtx))
    sub_mtx[AAtoAdd_row,] = 0
    sub_mtx[AAtoAdd_row,] = 0
    rbind(sub_mtx, matrix(0, nrow=length(AAtoAdd), ncol=ncol(sub_mtx),
                       dimnames=list(AAtoAdd, 1:ncol(sub_mtx))))
  }

dim(subMtx(prot_set, nat_prot))
dim(subMtx2(prot_set, nat_prot))
```

## Make some relevant plots of the results
```{r}
library(pheatmap)
# Heatmap of pair-substitution frequence
heatmap(subMtx2(prot_set, nat_prot)[AA_STANDARD, AA_STANDARD], 
        Rowv = NA, Colv = NA)

pheatmap(subMtx2(prot_set, nat_prot)[AA_STANDARD, AA_STANDARD])

# Heatmap of residue presence per position
heatmap(resFreqPerPos(prot_set),
        Rowv = NA, Colv = NA)
```



Now we would like to extract some information from these sequences. Let's see if we can create a function identyfying the mismatches between two sequences

```{r}
# Function where you introduce 
find_subs_dna = function(dna1, dna2, do_align=FALSE){
  positions = which(!as.integer(dna1)==as.integer(dna2))
  sapply(positions, \(pos) paste0(pos, dna1[pos], '>', dna2[pos]))
}
# Apply through all the sequences
unlist(sapply(set, \(dna) find_subs_dna(nat, dna)))
```



# ALL FUNCTIONS
## In case you want to use them without analyzing them one by one
```{r}
make_substitution = function(seq, site=FALSE, nucl=FALSE){
  if (site==FALSE){site=sample(c(1:nchar(seq)),1)}
  if (nucl==FALSE){nucl=sample(c('A','C','G','T'),1)}
  c(seq=replaceLetterAt(seq, at=site, nucl),
    mut=c(paste0(site, nat[site],'>',nucl)))}

freq_mtx = function(setSeqs, natProt=NULL, justSubs=F, as.prob=T){
  # Determine if there is a DNA or protein set
  if(class(setSeqs)=='AAStringSet'){alphabet=AA_ALPHABET}
  else if(class(setSeqs)=='DNAStringSet'){alphabet=DNA_ALPHABET}
  else{return(print('Introduce a Biostrings AAStringSet/DNAStringSet'))}
  
  # Determine residue's frequence at each position
  freq_mtx = as.matrix(setSeqs) %>% 
  as.data.frame() %>%
  apply(., 2, function(col){
  table(c(col, alphabet))-1}) 
  
  # Name columns as sequence-position + letter (if native seq is specified)
  if (is.null(natProt)){colnames(freq_mtx) = 1:ncol(freq_mtx)}
  else {colnames(freq_mtx) = paste0(1:nchar(natProt), as.vector(natProt))}
  
  # Keep or not the equal subs
  if (!is.null(natProt) && justSubs==T){
    for (l in 1:nchar(natProt)){freq_mtx[as.character(as.vector(natProt)[l]),l] =0 }
  }
  # Return the output
  if (as.prob==T) {return(freq_mtx/sum(freq_mtx))}
  else{return(freq_mtx)}
}  

sub_mtx = function(setSeqs, wildSeq, justSubs=F){
    # Determine if there is a DNA or protein set
  if(class(setSeqs)=='AAStringSet'){alphabet=AA_ALPHABET}
  else if(class(setSeqs)=='DNAStringSet'){alphabet=DNA_ALPHABET}
  else{return(print('Introduce a Biostrings AAStringSet/DNAStringSet'))}
  
  # Determine residue's frequence at each position
  freq_mtx = as.matrix(setSeqs) %>% 
  as.data.frame() %>%
  apply(., 2, function(col){
  table(c(col, alphabet))-1}) 

  # Group columns that share the same letter in the native sequence
  colnames(freq_mtx) = as.vector(wildSeq)
  sub_mtx = t(rowsum(t(freq_mtx), group=colnames(freq_mtx)))  # Returns sub_mtx
  
  # If just substitutions are of interest discard the concordances
  if (justSubs){for (l in colnames(sub_mtx)){sub_mtx[l,l] = 0 }}
  
  # Add lacking aminoaciads in columns
  LettersToAdd = setdiff(rownames(sub_mtx), colnames(sub_mtx))
  cbind(sub_mtx, matrix(0, nrow=nrow(sub_mtx), ncol=length(LettersToAdd),
                       dimnames=list(rownames(sub_mtx),
                                     LettersToAdd)))
}  
```


# Exercise 2: NGS for protein variants 

Some of the GFP mutations interfere with the function of GFP, so colonies with these mutations will tend to have unfuctional GFPs,, thus less fluorescence. Using a technique called FACS, beads were sorted into a bright, high fluorescence bin and a dim, low fluorescence bin. Both bins were subsequently sequenced.

Find out which protein level variants they code for and count how many
times each protein level variant is present in both bins.

```{r}
# We upload the two sets distinguished by low or high fluorescence
hDNAset = read.delim('ex2/bright_GFP_beads.counts', stringsAsFactors = F, header = F, col.names = c('Counts', 'Sequence'))
lDNAset = read.delim('ex2/dim_GFP_beads.counts', stringsAsFactors = F, header = F, col.names = c('Counts', 'Sequence'))

# Upload the native sequence
nat = readDNAStringSet('native_DNA.fa')[[1]]
```


Each of these sequences is a variant. Problems like sequencing errors mean
that there might be more unique sequences in the data than there were actual
unique variants in the sample. Use a criteria (based on counts) to discard the ones you suspect are product of a sequencing error

Other typical error in mutagenesis libraries are the random appearance of indels. Remove those sequences with gaps

```{r}
# Define a cleaning function for a FACS dataset (Col1:Counts, Col2:Sequence)
clean_FACS = function(DNAset){
  # Filter sequences with very low counts and with different DNA lenghts to the native
  DNAset_al = DNAset %>%
  filter(Counts > quantile(Counts, .25)-1.5*IQR(Counts)) %>% # Filter boxplot-low-outliers 
  filter(nchar(Sequence)==names(which.max(table(nchar(Sequence))))) %>% # Filter mode-length differings
  pull(Sequence) %>%
  DNAStringSet()

  # Exclude sequences with gaps (-) or other non-DNAbase letters (M, R, W...)
  only.dna.bases.seqs = rowSums(letterFrequency(DNAset_al,setdiff(DNA_ALPHABET, DNA_BASES)))==0
  DNAset_al[only.dna.bases.seqs]
}
```  

Now we clean the data in both datasets and translate it 
```{r}
# Clean + Translate the FACS datasets
hPROTset = translate(clean_FACS(hDNAset))
lPROTset = translate(clean_FACS(lDNAset))

# Translate the native sequence
natPROT = translate(nat)
```

Then we calcualte the (aminoacid) substitution matrix of each dataset (20x20) and represent the data

```{r}
# Representations (eliminating the dendograms so there is no reorder)
heatmap(sub_mtx(hPROTset, natPROT, justSubs = T)[AA_STANDARD, AA_STANDARD], 
        Rowv = NA, Colv = NA)

heatmap(sub_mtx(lPROTset, natPROT, justSubs = T)[AA_STANDARD, AA_STANDARD], 
        Rowv = NA, Colv = NA)
```

Plot the frequency of each substitution over the sequence. Based on the exercises description the frequency of a residue (a) in a particular sequence position (i) is defined as the division between the number of counts of that residue-position ($c_{ai}$) and the total number of missense variants ($n_{var}$):

$$ f_{ai} = c_{ai}/n_{var}$$ 



```{r}
# The frequency-position matrices
hfreqMtx = freq_mtx(hPROTset, natPROT, justSubs = T, as.prob = T) 
lfreqMtx = freq_mtx(lPROTset, natPROT, justSubs = T, as.prob = T)
```

  
Step 5: Now we are calculating the enriched protein variants in the dim and bright bins (functional rich/poor proteins). For this we will see the frequence of each variant in one or the other and make a log-odds ratio comparison:

$$substitution.score = log_{10}(var.freq.in.bright/var.freq.in.dim)$$
```{r}
# We are using pseudocounts in order to elude the apparition of NA and inifinite values in non-represented substitutions
enrichMtx = log10((hfreqMtx+1)/(lfreqMtx+1))

heatmap(enrichMtx[AA_STANDARD,], 
        Rowv = NA, Colv = NA)
library(pheatmap)
pheatmap(enrichMtx[AA_STANDARD,], cluster_rows = F, cluster_cols = F)
``` 

From the previous heatmap it is observed that those variants with T97>S97 substitutions present higher levels of function-activity for the GFP protein (higher fluorsencence, thus more likely to appear in the brim dataset). On the other hand, D64>Y64 seems to produce the opposite effect. 

When we look at the PDB structure file 1EMA corresponding to this protein.

The results can be explained and supported by the biochemical evidence XXX



For each position in the protein sequence, look at the distribution and average of substitution scores across all aa in that position.
```{r}
scoresPivoted = as.data.frame(enrichMtx) %>% 
  mutate(mutation=rownames(.))%>%
  pivot_longer(cols=colnames(.)[-ncol(.)],
               names_to = 'position',
               values_to = 'score')

# Lines
ggplot(scoresPivoted, aes(x=mutation, y=score, group=position, colour=position))+
  geom_line()+
  theme_classic()

# Boxplot
ggplot(scoresPivoted, aes(x=position, y=score))+
  geom_boxplot()+
  facet_wrap(~position)

# Avg of substitution score for all positions across all aa
colMeans(enrichMtx)
```


Then pick 3 amino acids that occur in your name and, analogously to above, look at the distribution and average of substitution scores for this amino acid across all positions. From my name, I take: G, E, R

```{r}
ggplot(scoresPivoted %>%
         filter(mutation %in% c('S', 'E', 'R')),
       aes(x=position, y=score, group=mutation,
           colour=mutation))+
  geom_line()

# Avg of substitution score for all aa across all positions
rowMeans(enrichMtx)
```









```{r}
allvarPROT = unique(c(unique(hPROTset), unique(lPROTset)))
hSeqFreqs = sort(table(c(hPROTset, allvarPROT))-1)`
lSeqFreqs = table(c(hPROTset, allvarPROT))-1

# Sort them so the division is done properly
hSeqFreqs=hSeqFreqs[order(names(hSeqFreqs))]
lSeqFreqs=lSeqFreqs[order(names(lSeqFreqs))]

# Perform the log-odds ratio
log10(hSeqFreqs/lSeqFreqs)

```
  

  
```{r}
library(bio3d)
get.pdb('1EMA')
prot_str = read.pdb('1EMA.pdb')
prot_str$seqres

# Use the same letter code
AA_CODE = setNames(names(AMINO_ACID_CODE), toupper(AMINO_ACID_CODE))
pdb_seq = sapply(unname(prot_str$seqres), \(l) AA_CODE[l])
pdb_seq = ifelse(is.na(pdb_seq), '+', pdb_seq)
pdb_seq = AAString(paste0(unname(pdb_seq), collapse = ''))

# Perform the alignment
pa = pairwiseAlignment(natPROT, pdb_seq)
as.character(pa)
summary(pa)
```


```{r}
grep('-', as.character(pa))
as.character(pa)
```
  
  
  
  
  
# Exercise 4

Goals: compare results from two different MAVE screens, and interpret the effects in the context of pathogenic/population observations, and (optionally) protein structures.

```{r}
# Upload the abundance scores and the phosphatase activity scores
ab_scores = read.table('ex4/prism_mave_003_PTEN_abundance.txt', skip=26, header=F, sep = '\t', col.names = c('variant', 'ABscore', 'ABstd'))

pa_scores = read.table('ex4/prism_mave_002_PTEN_phosphatase_activity.txt', skip=26, header=F, sep = '\t', col.names = c('variant', 'PAscore', 'PAstd'))

# Solve a little issue with the data type defined for one of the scores column
ab_scores$ABscore = as.numeric(ab_scores$ABscore)
pa_scores$PAscore = as.numeric(pa_scores$PAscore)

# As a control measure lets plot each of the file's distribution
hist(ab_scores$ABscore, main='Abundance score distribution')
hist(as.numeric(pa_scores$PAscore), main='Phosphatase-activity score distribution')

# Merge both data
scores = merge(ab_scores, pa_scores, by='variant')%>%
  mutate(variant = substr(variant, 1, nchar(variant)-1))
```
  
  


- We search in ClinVar for the gene name (PTEN) and select phatogenic in our filtering process. Afterwards we download a table in csv format. Then we respond the proposed questions:
- We also search in gnomeAD for the gene name (PTEN) in order to find more data. We download csv table (altough here it is needed to only select protein data)


Go to: https://simple-clinvar.broadinstitute.org/ and search for PTEN variants with clinical associations
And to:  https://gnomad.broadinstitute.org/gene/ENSG00000171862?dataset=gnomad_r2_1


How many missense variants are reported? 38
How many of those are also present in the population sequencing aggregation database gnomAD? 0
```{r}
clinvarPTEN = read.csv('ex4/ShinyClinVar_PTEN_2022-11-01.csv', row.names = 1)
phatoPTEN = subset(clinvarPTEN,clinvarPTEN$ClinicalSignificance=='Pathogenic')
table(phatoPTEN$consequence)['Missense']
phatoPTEN %>% filter(consequence=='Missense' & gnomAD_binary_char=='Yes') %>% nrow()
```
  

```{r}
# Create functions that transform the data
AA_CODE2 = setNames(c(names(AMINO_ACID_CODE), 'Ter'), c(unname(AMINO_ACID_CODE), '*'))
AA_coder = function(aa_vr){ifelse(is.na(aa_vr), NA, unname(AA_CODE2[aa_vr]))}


## CLINVAR
clinvarPTEN = read.csv('ex4/ShinyClinVar_PTEN_2022-11-01.csv', row.names = 1) %>%
  mutate(variant = paste0(AA_coder(ref_aa), pos_aa, AA_coder(alt_aa))) 


## GNOMEAD
PTENgnome = read.delim('ex4/gnomAD_v2.1.1_ENSG00000171862_2022_11_01_19_06_29.csv', sep=',') %>%
  filter(str_detect(HGVS.Consequence,'^p.')) %>%  # Select protein-related rows
  mutate(variant = gsub('^p.','', HGVS.Consequence))

gnomePositions = gsub('\\D', '', PTENgnome$variant)
gnomeLetters = lapply(strsplit(PTENgnome$variant, gnomePositions), \(vr) AA_coder(vr))
PTENgnome$variant = mapply(function(pos, l_vr){paste0(l_vr[1], pos, l_vr[2])}, 
                           gnomePositions, gnomeLetters, USE.NAMES = F)

# MERGE ALL DATA without loosing information
score.clinvar = merge(scores, clinvarPTEN, by='variant')
score.gnome = merge(scores, PTENgnome, by='variant')

allPTEN = merge(score.clinvar, score.gnome, by='variant', all.x=T, all.y=T) %>%
  mutate(IsInGnome = ifelse(is.na(ABscore.y), 'no', 'yes'),
         ABscore = ifelse(is.na(ABscore.x), ABscore.y, ABscore.x),
         ABstd = ifelse(is.na(ABscore.x), ABstd.y, ABstd.x),
         PAscore = ifelse(is.na(PAscore.x), PAscore.y, PAscore.x),
         PAstd = ifelse(is.na(PAstd.x), PAstd.y, PAstd.x)) %>%
  select(variant, ABscore, ABstd, PAscore, PAstd, ClinicalSignificance, IsInGnome)

# Make an initial scatter plot representation
ggplot(allPTEN, aes(ABscore, PAscore, color=ClinicalSignificance, shape=IsInGnome))+
  geom_point()
```

Based on this it seems possible that there is a correlation between the distinct groups and the two variables. Due to the fact that both of them go in the same direction maybe it is possible to consider them.

```{r}
ggplot(allPTEN, aes(ClinicalSignificance, ABscore, color=ClinicalSignificance, shape=IsInGnome))+
  geom_jitter()
```









I am now going over gnomAD and include new data: https://gnomad.broadinstitute.org/gene/ENSG00000171862?dataset=gnomad_r2_1

```{r}
PTENgnome = read.delim('ex4/gnomAD_v2.1.1_ENSG00000171862_2022_11_01_19_06_29.csv', sep=',')

# We select the rows with protein info and use the aminoacid mutation as our variant id
PTENgnome = PTENgnome %>%
  filter(str_detect(HGVS.Consequence,'^p.')) %>%
  mutate(variant = gsub('^p.','', HGVS.Consequence))

gnomePositions = gsub('\\D', '', PTENgnome$variant)
gnomeLetters = lapply(strsplit(PTENgnome$variant, gnomePositions), \(vr) AA_coder(vr))
PTENgnome$variant = mapply(function(pos, l_vr){paste0(l_vr[1], pos, l_vr[2])}, 
                           gnomePositions, gnomeLetters, USE.NAMES = F)

# Merge the data with the rest
PTENall = merge(allPTEN, PTENgnome, by='variant', all.x=T)

substr(PTENgnome$HGVS.Consequence, 4, stop=length(PTENgnome$HGVS.Consequence)) 







intersect(PTENgnome$variant, allPTEN$variant)
PTENall = merge(x=allPTEN, y=PTENgnome, by='variant', all.x=T)

```


